# Робота з файлами та винятками
**Мета**:  створити, відлагодити та протестувати програму, у якій реалізувати двонаправлений файловий ввід/вивід для обробки даних з використанням обробників винятків.

## Вказівки до роботи
Відповідно до цієї інструкції вам потрібно у середовищі Visual Studio Code з використанням набору компіляторів GCC створити програму мовою C++ для двонаправленого файлового вводу/виводу для обробки даних з базовим 
(батьківським), похідними (дочірніми) класами з використанням обробників винятків, перевантаженням операторів та віртуальними функціями. Також 
реалізувати відповідні конструктори, деструктори, методи. Використайте динамічний масив (вектор) структур для зберігання введених даних. Потрібно реалізувати багатофайловий проєкт у середовищі Visual Studio Code з описом кожного класу у відповідних парах заголовного та виконуваного файлів.

## Завдання
1. Вибрати завдання згідно свого варіанту у ДОДАТКУ.
2. Ознайомитися із винятками та їх обробкою. Обдумати способи їх використання для створення програм.
3. Ознайомитися із потоками вводу/виводу даних у файл. Обдумати способи їх використання для створення програм.
4. Створити батьківський та дочірні класи згідно свого варіанту.
5. Застосувати винятки та їх обробники для перевірки введення даних, відкриття файлів тощо.
6. Застосувати віртуальні функції (методи) для виведення даних із дочірніх класів.
7. Продемонструйте перевантаження операторів для певних цілей програми (конкатенації, порівняння тощо).
8. Розробити блок-схему алгоритму програми.
9. Реалізувати програму для вводу і зберігання даних полів (членів) структур вкладених у клас.

### Короткі відомості
#### 1. Винятки та їх обробка
При написанні повторно використовуваного коду виникає необхідність в обробці помилок. Одним з найбільш поширених способів обробки потенційних помилок є використання кодів повернення (або «кодів завершення»), які повертає оператор `return`. Наприклад:
```c++
int findFirstChar(const char* string, char ch)
{
    /* Перебираємо кожний символ рядка */
    for (int index=0; index < strlen(string); ++index)
    /* Якщо поточний символ співпадає зі значенням змінної ch, 
    то повертаємо індекс цього символу */
        if (string[index] == ch)
            return index;
        // Якщо збігу не виявлено, то повертаємо -1
    return -1;
}
```
Ця функція повертає індекс першого символу переданого рядка, який збігається зі значенням змінної `ch`. Якщо символ не знайдено, то функція повертає -1 в якості індикатора помилки. Головною перевагою цього підходу є його простота. Однак є ряд недоліків, які можуть швидко проявитися в нетривіальних ситуаціях.

По-перше, значення, що повертаються, не завжди зрозумілі. Якщо функція повертає -1, то чи означає це якусь специфічну помилку чи може це взагалі коректне значення? Часто важко зрозуміти, не маючи перед очима код самої функції.

По-друге, функції можуть повертати лише одне значення. А що, якщо нам потрібно буде повернути як результат виконання функції, так і код завершення? Один з варіантів — повернення результату операції або коду завершення по посиланню.

По-третє, коли коду багато, то багато речей можуть піти не по плану, тому коди повернення потрібно постійно перевіряти. 

По-четверте, коди повернення не дуже добре поєднуються з конструкторами. Що станеться, якщо ми створимо об’єкт, а всередині конструктора відбудеться щось катастрофічне? Конструктори не можуть використовувати оператор `return`для повернення індикатора стану, а передача по посиланню може заподіяти масу незручностей, і її потрібно явно перевіряти. Крім того, навіть якщо ми це зробимо, об’єкт все одно створиться, і “лікувати” ми вже будемо наслідки (або обробляти, або видаляти).

Основна проблема з кодами повернення полягає в тому, що вони щільно пов’язані із загальним потоком виконання коду, а це, в свою чергу, обмежує наші можливості. Обробка винятків якраз і забезпечує механізм, який дозволяє відокремити обробку помилок або інших виняткових обставин від загального потоку виконання коду. Це надає більше свободи в конкретних ситуаціях, зменшуючи при цьому безлад, який створюють коди повернення.

У мові C++ оператор `throw` використовується для сигналізування про виникнення винятку або помилки. Сигналізування про те, що стався виняток, називається генерацією винятку (або “викиданням винятку”).

Для використання оператора `throw` застосовується ключове слово `throw`, а за ним вказується значення будь-якого типу даних, яке ви хочете використати, щоб сигналізувати про помилку. Як правило, цим значенням є код помилки, опис проблеми або спеціальний клас-виняток.

У мові C++ ми використовуємо ключове слово `try` для визначення блоку стейтментів (так званого «блоку `try`»). Блок try діє як спостерігач в пошуках винятків, які були викинуті будь-яким з операторів в цьому ж блоці `try`.

Власне блок `try` не визначає, як ми оброблятимемо виняток. Він просто повідомляє компілятору: «Якщо будь-який зі стейтментів всередині цього блоку `try` згенерує виняток — злови його!». Фактично, обробка винятків — це робота блоку(ів) `catch`. Ключове слово `catch` використовується для визначення блоку коду (так званого «блоку `catch`»), який обробляє винятки певного типу даних. 

Блоки `try` і `catch` працюють разом. Блок `try` виявляє будь-які винятки, які були викинуті в ньому, і направляє їх до відповідного блоку catch для обробки. Блок `try` повинен мати, принаймні, один блок `catch`, який знаходиться відразу ж за ним, але також може мати і кілька блоків `catch`, розміщених послідовно (один за одним).

Як тільки виняток було спіймано блоком `try` і направлено в блок `catch` для обробки, він вважається обробленим (після виконання коду блоку `catch`), і програма відновлює своє виконання. Параметри `catch` працюють так само, як і параметри функції, причому параметри одного блоку `catch` можуть бути доступні і в іншому блоці `catch` (який знаходиться за ним). Винятки фундаментальних типів даних можуть бути спіймані по значенню (параметром блоку `catch` є значення), але винятки нефундаментальних типів даних повинні бути спіймані по константному посиланню (параметром блоку `catch` є константне посилання), щоб уникнути непотрібного копіювання.

Використання `throw`, `try` і `catch` разом можна продемонструвати на прикладі програми, яка використовує `throw`, `try` і кілька блоків `catch`:
```c++
#include <iostream>
#include <string>
int main()
{
    try
    {
    /* Тут ми пишемо стейтменти, які генеруватимуть наступний
    виняток */
    throw -1; // типовий стейтмент throw
    }
    catch (int a)
    {
    /* Будь-які винятки типу int, згенеровані в блоці try,
    наведеному вище, обробляються тут */
    std::cerr << "We caught an int exception with value: " << a << '\n';
    }
    /* ми не вказуємо ім'я змінної, тому що в цьому немає
    необхідності (ми її ніде в блоці не використовуємо) */
    catch (double) 
    {
    /* Будь-які винятки типу double, згенеровані в блоці try, 
    наведеному вище, обробляються тут */
    std::cerr << "We caught an exception of type double" << '\n';
    }
    /* ловимо винятки по константному посиланню */
    catch (const std::string &str) 
    {
    /* Будь-які винятки типу std::string, згенеровані всередині
    блоку try, наведеному вище, обробляються тут */
    std::cerr << "We caught an exception of type std::string" << '\n';
    }
    std::cout << "Continue!\n";
    return 0;
}
```
Результат виконання програми:
```
We caught an int exception with value -1
Continue!
```
Оператор `throw` використовується для генерації винятку -1 типу `int`. Потім блок `try` виявляє оператор `throw` і переміщує його до відповідного блоку `catch`, який обробляє винятки типу `int`. Блок `catch` типу `int` і виводить відповідне повідомлення про помилку. Після обробки винятку, програма продовжує своє виконання і виводить на екран `Continue!`

 При викиданні винятку (оператор `throw`), точка виконання програми негайно переходить до найближчого блоку `try`. Якщо будь-який з обробників `catch`, прикріплених до блоку `try`, обробляє цей тип винятку, то точка виконання переходить в цей обробник і, після виконання коду блоку `catch`, виняток вважається обробленим.  Якщо відповідних обробників catch немає, то виконання програми переходить до наступного блоку `try`. Якщо до кінця програми не знайдені відповідні обробники `catch`, то програма завершує своє виконання з помилкою винятку.

Звернітьувагу, компілятор не виконує неявні конвертації при зіставленні винятків з блоками `catch`! Наприклад, виняток типу char не оброблятиметься блоком `catch` типу `int`, а виняток типу `int`, в свою чергу, не оброблятиметься блоком `catch` типу `float`. Якщо виняток направлено в блок `catch`, то він вважається «обробленим», навіть якщо блок `catch` порожній. Однак, як правило, ви захочете, щоб ваші блоки `catch` робили щось корисне. Є три найпоширеніші речі, які виконують блоки `catch`, коли вони зловили виняток:

По-перше, блок `catch` може вивести повідомлення про помилку в консоль або в лог-файл.

По-друге, блок `catch` може повернути значення або код помилки назад в caller.

По-третє, блок `catch` може згенерувати інший виняток. Оскільки блок `catch` не знаходиться всередині блоку `try`, то новий згенерований виняток оброблятиметься наступним блоком try.

Винятки обробляються негайно. Ось приклад програми, яка це демонструє:
```c++
#include <iostream> 
#include <cmath> 
int main()
{
    std::cout << "Enter a number: ";
    double a;
    std::cin >> a;
 
    try
    /* шукаємо винятки всередині цього блоку і відправляємо їх
    у відповідний обробник catch */
    {
    /* Якщо користувач ввів від'ємне число, то викидається
    виняток */
        if (a < 0.0) {
            /* викидається виняток типу const char* */
            throw "Can not take sqrt of negative number"; 
        }
        /* Якщо користувач ввів додатне число, то виконується
        операція і виводиться результат */
        std::cout << "The sqrt of " << a << " is " << sqrt(a) << '\n';
    }
    /* обробник винятків типу const char* */
    catch (const char* exception) 
    {
        std::cerr << "Error: " << exception << '\n';
    }
}
```
Тут ми просимо користувача ввести число. Якщо користувач ввів додатне число, то стейтмент `if` не виконується, виняток не генерується, і користувач отримує квадратний корінь з числа. Оскільки виняток не генерується, то код всередині блоку `catch` ніколи не виконується.

Результат:
```
Enter a number: 16
The sqrt of 16 is 4
```
Якщо ж користувач ввів від’ємне число, то генерується виняток типу `const char*`. Оскільки ми вже знаходимося в блоці `try`, то компілятор шукає відповідний обробник `catch` типу `const char*`, і точка виконання негайно переміщується в цей блок.

Результат:
```
Enter a number: -3
Error: Can not take sqrt of negative number
```
Генерація винятків за межами блоку `try`. У попередньому прикладі оператори `throw` поміщалися безпосередньо в блок `try`. Якби це було обов’язковою умовою, то обробка винятків не була б гнучкою взагалі. Насправді стейтменти `throw` зовсім не обов’язково поміщати в блок `try`, завдяки виконанню такої операції, як “розкручування стеку”. Це надає нам необхідну гнучкість в поділі загального потоку виконання коду програми і обробки винятків. 

Продемонструємо це, переписавши програму з попереднього прикладу, винісши генерацію винятку і обчислення квадратного кореня в окрему функцію:
```c++
#include <iostream>
#include <cmath> 
 
/* Окрема функція обчислення квадратного кореня */
double mySqrt(double a)
{
/* Якщо користувач ввів від'ємне число, то генеруємо виняток */
    if (a < 0.0) {
        /* генерується виняток типу const char* */
        throw "Can not take sqrt of negative number"; 
    }
 
    return sqrt(a);
}
int main()
{
    std::cout << "Enter a number: ";
    double a;
    std::cin >> a;
 
    try 
/* шукаємо винятки, які генеруються в блоці try, і відправляємо
їх для обробки в блок(и) catch */
    {
        double d = mySqrt(a);
        std::cout << "The sqrt of " << a << " is " << d << '\n';
    }
/* обробка винятків типу const char* */
    catch (const char* exception) 
    {
        std::cerr << "Error: " << exception << std::endl;
    }
 
    return 0;
}
```
Тут ми перемістили генерацію винятку і операцію обчислення квадратного кореня в окрему функцію `mySqrt()`. Потім ми викликаємо цю функцію в блоці `try`. Переконаємося, що все працює, як потрібно:
```
Enter a number: -3
Error: Can not take sqrt of negative number
```
Повернемося до моменту генерації винятку і розглянемо хід виконання програми. По-перше, при генерації винятку компілятор дивиться, чи можна відразу ж обробити цей виняток (для цього потрібно, щоб виняток генерувався всередині блоку `try`). Оскільки точка виконання знаходиться не всередині блоку `try`, то і обробити виняток відразу ж не вийде. Таким чином, виконання функції `mySqrt()` припиняється, і програма дивиться, чи може caller (який і викликає `mySqrt()`) обробити цей виняток.

Якщо ні, то компілятор завершує виконання caller-а і переходить на рівень вище — до caller-у, який викликає поточного caller-а, щоб перевірити, чи зможе той обробити виняток. І так послідовно до тих пір, поки не буде знайдено відповідний обробник винятку, або поки функція `main()` не завершить своє виконання без обробки винятку. Цей процес називається розкручуванням стеку.

Тепер розглянемо детально, як це відноситься до нашої програми. Спочатку компілятор перевіряє, чи генерується виняток всередині блоку `try`. У нашому випадку — ні, тому стек починає розкручуватися. При цьому функція `mySqrt()`завершує свою роботу і точка виконання переміщається назад в функцію `main()`. Тепер компілятор перевіряє знову, чи перебуваємо ми всередині блоку `try`. Оскільки виклик функції `mySqrt()` був виконаний з блоку `try`, то компілятор починає шукати відповідний обробник `catch`. Він знаходить обробник типу `const char*`, і виняток обробляється блоком catch всередині функції `main()`. Функція `mySqrt()` генерує виняток, але блоки `try/catch`, які знаходяться в `main()`, ловлять і обробляють цей виняток. Іншими словами, блок `try` ловить виняток не тільки всередині себе, а й всередині функцій, які викликаються в цьому блоці `try`.

Найцікавіше тут в тому, що `mySqrt()` наче повідомляє компілятору про проблему, але обробляти її проблему `mySqrt()` відмовляється. Це, по суті, делегування відповідальності за обробку винятку на caller аналогічно тому, як при використанні кодів завершення відповідальність за обробку помилок перекладається назад на caller. Чому б просто не змусити функцію `mySqrt()`обробляти власні винятки?». Проблема в тому, що різні програми обробляють помилки/винятки по-різному. В одній програмі це може бути критичною помилкою, а в іншій — ні. Передаючи помилку назад в стек, кожна програма може обробляти виняток `mySqrt()` таким чином, який є найбільш відповідним по контексту. Це дозволяє відокремити функціонал `mySqrt()` від коду обробки винятків, який можна розмістити в інших (менш важливих) частинах коду.

Розкручування стеку є дуже корисним механізмом, тому що дозволяє функціям не обробляти винятки, якщо вони цього не хочуть. Операція розкручування стеку виконується до тих пір, поки не буде виявлено відповідний блок `catch`. Таким чином, ми можемо самі вирішувати, де саме нам слід обробляти винятки. 

Мова програмування C++ надає нам механізм виявлення/обробки всіх типів винятків — обробник `catch-all`. Обробник `catch-all` працює так само, як і звичайний блок `catch`, за винятком того, що замість обробки винятків певного типу даних, він використовує еліпсис (...) в якості типу даних. 

Функції, які використовують еліпсис, виглядають наступним чином:

*тип_повернення* *ім'я_функції*(*список_аргументів*, ...)

*список_аргументів* — це один або декілька звичайних параметрів функції.

Функції, які використовують еліпсис, повинні мати принаймні один параметр, який не є еліпсисом. Еліпсис (англ. “ellipsis”), який представлений у вигляді трьох крапок … в мові C++, завжди повинен бути останнім параметром у функції і містить будь-які інші параметри, крім тих, які вказані в список_аргументів. Еліпсиси можуть використовуватися для передачі аргументів будь-якого типу даних в функцію. У цьому контексті вони представляють собою винятки будь-якого типу даних. 
```c++
#include <iostream>
 
int main()
{
try
{
    throw 7; // генерується виняток типу int
}
catch (double a)
{
    std::cout << "We caught an exception of type double: " << a << 
'\n';
}
catch (...) // обробник catch-all
{
    std::cout << "We caught an exception of an undetermined type!
\n";
}
}
```
Оскільки для типу `int` не існує спеціального обробника `catch`, то обробник `catch-all` ловить цей виняток. Отже, результат:
```
We caught an exception of an undetermined type!
```
Обробник `catch-all` повинен знаходитися останнім в ланцюжку блоків `catch`. Це робиться для того, щоб винятки спочатку могли бути спіймані обробниками `catch`, адаптованими до конкретних типів даних (якщо вони взагалі існують). 

Часто блок обробника `catch-all` залишають порожнім:
```c++
сatch(...) {} // ігноруюься будь-які непередбачувані винятки
```
В такому випадку обробник ловить будь-які непередбачені винятки і запобігає розкручуванню стеку (і потенційному завершенню виконання програми), але тут він не виконує ніякої обробки винятків.

Розглянемо винятки в перевантаженні операторів, а саме перевантаження оператора індексації `[]` для простого цілочисельного класу-масиву: На жаль, оскільки перевантаження операторів має особливі вимоги до кількості та типу параметрів, які вони можуть приймати і повертати, немає ніякої гнучкості для передачі кодів помилок або логічних значень назад в caller. Однак, ми можемо використовувати винятки, які не змінюють сигнатуру функції, наприклад:
```c++
int& ArrayInt::operator[](const int index)
{
    if (index < 0 || index >= getLength())
        throw index;
    return m_data[index];
}
```
Тепер, якщо користувач передасть неприпустимий `index`, `operator[]` згенерує виняток типу `int`. Використаємо цей спосіб у наступному прикладі.

Одним із способів вирішення проблеми обробки винятків з різних місць по-різному  є використання класів-винятків. Клас-виняток — це звичайний клас, який генерується в якості винятку. Створимо простий клас-виняток `ArrayException`, який використовуватиметься з класом `ArrayInt`:
```c++
#include <iostream>
#include <string>
class ArrayException
{
private:
    std::string m_error;
public:
    ArrayException(std::string error) : m_error(error)
    {
    }
 const char* getError() { return m_error.c_str(); }
};
class ArrayInt
{
private:
    /* вкажемо значення 4 в якості довжини масиву */
    int m_data[4];
public:
    ArrayInt() {}
    int getLength() { return 4; }
    int& operator[](const int index)
    {
        if (index < 0 || index >= getLength())
            throw ArrayException("Invalid index");
        return m_data[index];
    }
};
int main()
{
    ArrayInt array;
    try
    {
        int value = array[7];
    }
    catch (ArrayException &exception)
    {
        std::cerr << "An array exception occurred (" << exception.getError() << ")\n";
    }
}
```
Використовуючи такий клас, ми можемо генерувати виняток, який повертає опис виниклої проблеми. Це дасть нам точно зрозуміти, що саме пішло не так. І, оскільки виняток `ArrayException` має унікальний тип, ми можемо обробляти його відповідним чином (не так як інші винятки). В обробниках винятків об’єкти класу-винятку потрібно приймати по посиланню, а не по значенню. 

Оскільки ми можемо генерувати об’єкти класів в якості винятків, а класи можуть бути отримані з інших класів, то нам потрібно враховувати, що станеться, якщо ми будемо використовувати успадковані класи в якості винятків.

Виявляється, обробники можуть обробляти винятки не тільки одного певного класу, а й винятки дочірніх йому класів.  Обробники винятків дочірніх класів повинні знаходитися перед обробниками винятків батьківського класу.
```c++
#include <iostream>
class Parent
{
public:
    Parent() {}
};
class Child: public Parent
{
public:
    Child() {}
};
 
int main()
{
    try
    {
        throw Child();
    }
    catch (Child &child)
    {
        std::cerr << "caught Child";
    }
    catch (Parent &parent)
    {
        std::cerr << "caught Parent";
    }
    return 0;
}
```
Результат:
```
caught Child
```
Таким чином, обробник `Child` ловитиме і оброблятиме винятки класу `Child`. Винятки класу `Parent` не відповідають обробнику `Child` (`Child` «є» `Parent`, але `Parent` «не є» `Child`) і, відповідно, оброблятимуться тільки обробником Parent.

Також мова С++ має вбудований інтерфейсний клас `std::exception`, який використовується в якості батьківського класу для будь-якого винятку, який генерується в Стандартній бібліотеці C++. У більшості випадків, якщо виняток генерується Стандартною бібліотекою С++, то нам досить знати, що сталося щось катастрофічне, через що в нашій програмі стався збій. Завдяки `std::exception` ми можемо налаштувати обробник винятків типу `std::exception`, який ловитиме і оброблятиме як `std::exception`, так і всі (20+) дочірні йому класи-винятки!
```c++
#include <iostream>
#include <exception>
#include <string>
 
int main()
{
    try
    {
        /* Тут повинен знаходитися код, який використовує
        Стандартну бібліотеку С++. 
        Зараз ми навмисно спровокуємо генерацію одного з винятків */
        std::string s;
        s.resize(-1); // генерується виняток std::bad_alloc
    }
    /* Цей обробник ловить std::exception і всі дочірні йому 
    класи-винятки */
    catch (std::exception &exception)
    {
        std::cerr << "Standard exception: " << exception.what() << '\n';
    }
    
    return 0;
}
```
Результат виконання програми:
```
Standard exception: string too long
```
У цьому прикладі все досить просто. В `std::exception` є віртуальний метод `what()`, який повертає рядок c-style з описом винятку. Більшість дочірніх класів перевизначають функцію `what()`, змінюючи це повідомлення. Можна створювати свої власні класи-винятки, використовувати класи-винятки зі Стандартної бібліотеки С++ чи писати класи-винятки, дочірні `std::exception`. Все залежить від ваших цілей. 

#### 2. Класи файлового вводу/виводу
Є три основні класи файлового вводу/виводу в мові C++:
- `ifstream` (є дочірнім класу `istream`);
- `ofstream` (є дочірнім класу `ostream`);
- `fstream` (є дочірнім класу `iostream`).

За допомогою цих класів можна виконувати однонаправлений файловий ввід (`ifstream`), однонаправлений файловий вивід (`ofstream`) і двонаправлений файловий ввід/вивід (`fstream`). Для їх використання потрібно всього лише підключити заголовок `fstream`.

На відміну від потоків `cout`, `cin`, `cerr` і `clog`, які відразу ж можна використовувати, файлові потоки повинні бути явно встановлені програмістом. Тобто, щоб відкрити файл для читання і/або запису, потрібно створити об’єкт відповідного класу файлового вводу/виводу, вказавши ім’я файлу в якості параметра. Потім, за допомогою оператора вставки (`<<`) або оператора вилучення (`>>`), можна записувати дані в файл або зчитувати вміст файлу. 

Вивід в мові C++ може бути буферизований. Це означає, що все, що виводиться в файловий потік, не може відразу ж бути записано на диск (в конкретний файл). Це зроблено, в першу чергу, з міркувань продуктивності. Коли дані буфера записуються на диск, то це називається очищенням буфера. Одним із способів очищення буфера є закриття файлу. У такому випадку весь вміст буфера буде переміщено на диск, а потім файл буде закрито.

Буферизація виводу зазвичай не є проблемою, але при певних обставинах вона може викликати проблеми у необережних новачків. Наприклад, коли в буфері зберігаються дані, а програма передчасно завершує своє виконання в результаті збою або шляхом виклику функції `exit()`. У таких випадках деструктори класів файлового вводу/виводу не виконуються, файли ніколи не закриваються, буфери не очищаються і наші дані губляться назавжди. Ось чому гарною ідеєю є явне закриття всіх відкритих файлів перед викликом функції `exit()`.

Конструктори файлового потоку приймають необов’язковий другий параметр, який дозволяє вказати програмісту спосіб відкриття файлу. В якості цього параметра можна передавати наступні прапорці, які знаходяться в класі `ios`:
- `app` — відкриває файл в режимі додавання;
- `ate` — переходить в кінець файлу перед читанням/записом;
- `binary` — відкриває файл в бінарному режимі (замість текстового режиму);
- `in` — відкриває файл в режимі читання (за замовчуванням для `ifstream`);
- `out` — відкриває файл в режимі запису (за замовчуванням для `ofstream`);
- `trunc` — видаляє файл, якщо він вже існує.

Можна вказати відразу кілька прапорців шляхом використання побітового АБО (`|`).
- `ifstream` за замовчуванням працює в режимі `ios::in`;
- `ofstream` за замовчуванням працює в режимі `ios::out`;
- `fstream` за замовчуванням працює в режимі `ios::in` АБО `ios::out`, що означає, що ви можете виконувати як читання вмісту файлу, так і запис даних в файл.

Після виконання даних дій потрібно закрити файл — явно викликати метод `close()` або просто дозволити файловій змінній вводу/виводу вийти з області видимості (деструктор файлового класу вводу/виводу закриє цей файл автоматично замість нас).
```c++
#include <iostream>
#include <cstdlib> // для використання функції exit()
#include <fstream>
int main()
{
    using namespace std;
    /* Передаємо прапорець ios:app, щоб повідомити fstream, 
    що ми збираємося додати свої дані до файлу.
    Нам не потрібно передавати прапорець ios::out, оскільки
    ofstream за замовчуванням працює в режимі ios::out 
    */
    ofstream outf("SomeText.txt", ios::app);
    /* Якщо ми не можемо відкрити файл для запису даних */
    if (!outf)
    {
        /* то виводимо наступне повідомлення про помилку і
        виконуємо функцію exit() */
        cerr << "Uh oh, SomeText.txt could not be opened for writing!" 
        << endl;
        exit(1);
    }
    outf << "See line #1!" << endl;
    outf << "See line #2!" << endl;
    return 0;
    /* Коли outf вийде з області видимості, то деструктор класу ofstream 
    автоматично закриє наш файл */
}
```
Так як ми явно закриваємо файл за допомогою методу `close()`, ми можемо явно відкривати файл за допомогою функції `open()`. Функція `open()` працює аналогічно конструкторам класу файлового вводу/виводу: приймає ім’я файлу і режим (необов’язково), в якому потрібно відкрити файл, в якості параметрів.  
```c++
#include <fstream>
 
int main()
{
    using namespace std;
    ofstream outf("SomeText.txt");
    outf << "See line #1!" << endl;
    outf << "See line #2!" << endl;
    outf.close(); // явно закриваємо файл
    outf.open("SomeText.txt", ios::app);
    outf << "See line #3!" << endl;
    outf << "See line #4!" << endl;
    outf.close(); // явно закриваємо файл
    return 0;
}
```

### Оформлення звіту
У звіті студент має вказати свій варіант індивідуального завдання та представити:
1. Блок-схему алгоритму програми.
2. Код (лістинг) програми.
3. Результати тестування для різних вхідних умов.
4. Конструктивний висновок — що ви дізналися нового, чого навчилися, якими способами та інструментами досягнули мети.

## ДОДАТОК

### Варіанти завдань

|  № |       Батьківський клас       |                   Дочірні класи                  |
|----|-------------------------------|--------------------------------------------------|
|  1 | Джерело живлення              | Павербанк, бензиновий/дизель генератор           |
|  2 | Сенсор                        | Датчик температури, датчик світла                |
|  3 | Прилад                        | Мультиметр, осцилограф                           |
|  4 | Провідник сигналів            | Коаксіальний кабель, оптоволокно                 |
|  5 | Радіостанція                  | Базова станція, портативна рація                 |
|  6 | Мікросхема                    | Логічна мікросхема, пам’ять                      |
|  7 | Фільтр                        | Фільтр нижніх частот, смуговий фільтр            |
|  8 | Транзистор                    | Біполярний транзистор, польовий транзистор       |
|  9 | Напівпровідниковий діод       | Стабілітрон, тунельний діод                      |
| 10 | Комунікаційний пристрій       | Маршрутизатор, комутатор                         |
| 11 | Канал передавання даних       | Радіоканал, оптоволоконний канал                 |
| 12 | Двигун                        | Серводвигун, кроковий двигун                     |
| 13 | Зчитувач інформації           | Сканер штрих-коду, RFID-зчитувач                 |
| 14 | Електронна плата              | Макетна плата, друкована плата                   |
| 15 | Контролер                     | Мікроконтролер, програмований логічний контролер |
| 16 | Акумулятор                    | Літій-іонний, свинцево-кислотний                 |
| 17 | Антена                        | Всеспрямована антена, антена направленої дії     |
| 18 | Електромагнітний випромінювач | Світлодіод, лазер                                |
| 19 | Оптичний компонент            | Світлодіод, фоторезистор                         |
| 20 | Звуковий пристрій             | Мікрофон, динамік                                |
| 21 | Дисплей                       | Рідкокристалічний дисплей, OLED-дисплей          |
| 22 | Бездротова технологія         | WiFi, Bluetooth                                  |
| 23 | Операційна система            | Android, iOS                                     |
| 24 | Резонатор                     | Кварцовий резонатор, керамічний резонатор        |
| 25 | Супутниковий термінал         | Термінал для зв’язку, термінал для телебачення   |
| 26 | Датчик руху                   | Інфрачервоний датчик, радарний датчик            |
| 27 | Перетворювач напруги          | Підсилювач напруги, послаблювач напруги          |
| 28 | Реле                          | Електромагнітне реле, твердотільне реле          |
| 29 | Мобільний телефон             | Кнопковий телефон, смартфон                      |
| 30 | Електронний компонент         | Пасивний компонент, активний компонент           |
